\documentclass[11pt]{scrartcl} % Font size
\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{
	\normalfont\normalsize
	\textsc{Harvard Privacy Tools Project}\\ % Your university, school and/or department name(s)
	\vspace{25pt} % Whitespace
	\rule{\linewidth}{0.5pt}\\ % Thin top horizontal rule
	\vspace{20pt} % Whitespace
	{\huge Snapping Mechanism Notes}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
	\vspace{12pt} % Whitespace
}

\author{\LARGE Christian Covington} % Your name

\date{\normalsize\today} % Today's date (\today) or a custom date

\begin{document}
\maketitle % Print the title

\section{Introduction}
The implementation of the snapping mechanism utilizes a number of ideas described in \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.366.5957&rep=rep1&type=pdf}{Mironov (2012)}\footnote{specifically in section 5.2} that, as far as I can tell, are not commonly seen in implementations of other DP algorithms. This document provides an overview of these ideas. \newline

\section{Mechanism Definitions}
Below we present the mechanisms as if they are operating on the set 64-bit floating point numbers, $\mathbb{D}$, rather than $\mathbb{R}$. We will use $\oplus$ and $\otimes$ to represent the floating-point implementations of addition and multiplication, respectively.

\subsection{Laplace Mechanism}
Let $f$ be a function computed on a data set $D$ with sensitivity $\Delta_f$ and $\epsilon$ be the desired privacy parameter. Further, let $\lambda = \frac{\Delta_f}{\epsilon}$. Then the Laplace Mechanism is defined as:
\[ M_{L}(D, f(\cdot), \lambda) = f(D) \oplus Y \]
where $Y \sim Laplace(\lambda)$.

\subsection{Snapping Mechanism}
\label{subsec:snapping}
Let $B$ be a user-chosen quantity that reflects beliefs about reasonable bounds on $f(D)$ and $\Lambda$ be the smallest power of two at least as large as $\lambda$. Using the same notation as above, the snapping mechanism is defined as:
\[ M_{S}(D, f(\cdot), \lambda, B) = clamp_{B}\left( \lfloor clamp_{B}\left( f(D) \right) \oplus Y \rceil_{\Lambda} \right). \]
where $clamp_{B}(\cdot)$ restricts output to the interval $[-B, B]$ and $\lfloor \cdot \rceil_{\Lambda}$ rounds to the nearest multiple of $\Lambda$, with ties resolved toward $+ \infty$.

\section{Sampling from the Laplace}
Mironov presents the Laplace noise as
\[ S \otimes \lambda \otimes LN(U^*) \]
where $S$ is a uniform draw over $\{\pm 1\}$, $\lambda = \frac{\Delta_f}{\epsilon}$, $LN(\cdot)$ is the floating-point implementation of the natural logarithm with exact rounding, and $U^*$ is the uniform distribution over $\mathbb{D} \cap (0,1)$ such that each double is output with proportion relative to its \href{https://en.wikipedia.org/wiki/Unit_in_the_last_place}{unit of least precision}. $\oplus$ and $\otimes$ are the floating-point implementations of addition and multiplication, respectively. \newline

Drawing $S$ should be done with whichever source of randomness we end up wanting to use. The current Python implementation uses system-level randomness by utilizing an instance of the \textbf{random.SystemRandom} class. \newline

We get $U^*$ as Mironov suggests, by sampling our exponent from a geometric distribution with parameter $p = 0.5$ and a mantissa uniformly from $\{0,1\}^{52}$. Let $e$ be a draw from $Geom(0.5)$ and $m_1, m_2 \hdots, m_{52}$ be the bits of our mantissa. Then we have
\[ U^{*} = (1.m_1m_2 \hdots m_{52})_2 * 2^{- e}. \]
The unit of least precision is completely decided by the value of $e$, so the floating-point values within each unit of least precision are uniformly distributed. Drawing $e$ from the geometric ensures that the probability of drawing a value from a given band is equal to the size of the band. \newline

$LN(\cdot)$ must be implemented with exact rounding, which we define below.\footnote{For all rounding, we assume that our goal is to round to the nearest number we are able to represent.} Consider that for an arbitrary $x \in \mathbb{D}$ the natural log of $x$ is not necessarily $\in \mathbb{D}$. Let $a < ln(x) < b$ where $a,b \in \mathbb{D}$ and $\not\exists c \in \mathbb{D}: a < c < b$. Without loss of generality, assume that $\vert a-x \vert < \vert b - x \vert$, so that if we had infinite precision in calculating $ln(x)$ (but still had to output an element $\in \mathbb{D}$), we would output $a$.
Many mathematical libraries do what is called \textit{accurate-faithful} rounding, which means that in the scenario above our algorithm would output $a$ with high probability. In an \textit{exact rounding} paradigm, the algorithm outputs $a$ with probability 1. You can read more about exact rounding in section 1.1 \href{http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-37.pdf}{here}. Section 2.1 of the paper just linked appeals to proofs from a set of papers that say you need 118 bits of precision, in the worst case, to calculate the logarithm with exact rounding. So, the current implementation calculates $LN(U^*)$ with at least 118 bits of precision.\footnote{We potentially use $> 118$ because of the $\epsilon$ redefinition described later.} \newline

Finally, we can choose to perform $\oplus$ and $\otimes$ with greater than normal precision if we so choose. For now, we are using the same 118 bits of precision for all the basic floating-point operations, using the assumption that exact rounding of basic arithmetic operations should require less precision than calculating the log. This should probably be made more rigorous at some point.

\section{Implementation of $\lfloor \cdot \rceil_{\Lambda}$}
The $\lfloor \cdot \rceil_{\Lambda}$ function takes an input and rounds it to the nearest multiple of $\Lambda$, where $\Lambda$ is the smallest power of two greater than or equal to $\lambda$. There are multiple steps to this implementation that are worth explaining.

\subsection{Finding $\Lambda$}
The algorithm receives $\lambda$ as input, but must find $\Lambda$ itself. First, represent $\lambda$ in its \href{https://en.wikipedia.org/wiki/Double-precision_floating-point_format}{IEEE-754 64-bit floating-point format}:
\[ \lambda = (-1)^S (1.m_{1} \hdots m_{52})_2 * 2^{(e_1 \hdots e_{11})_2-1023}. \]
We know $\lambda > 0$, so we know $S = 0$. Now, note that powers of two correspond exactly to the IEEE representations with $m_1 = \hdots = m_{52} = 0$. If $\lambda$ is already a power of two, then we simply return $\lambda$. Otherwise, we get the smallest power of two greater than $\lambda$ by changing to mantissa to $(0 \hdots 0)_2$ and increasing the exponent by 1. So, we have
\begin{equation}
    \Lambda =
        \begin{cases}
            \lambda, & \text{ if } m_1 = \hdots = m_{52} = 0 \\
            (1.0 \hdots 0)_2 * 2^{(e_1 \hdots e_{11})_2-1022}, & \text{ if } \exists i: m_i \neq 0
        \end{cases}
\end{equation}

\subsection{Rounding to nearest multiple of $\Lambda$}
We now want to round our input $x$ to the nearest multiple of $\Lambda$. We do so via a three-step process:
\begin{enumerate}
    \item $x' = \frac{x}{\Lambda}$
    \item Round $x'$ to nearest integer, yielding $x''$
    \item $\lfloor x \rceil_{\Lambda} = \Lambda x''$
\end{enumerate}
We split the process into three steps because each step can be performed exactly (with no introduction of floating-point error) via manipulation of the IEEE floating-point representation.

\subsubsection{Calculate $x' = \frac{x}{\Lambda}$}
We can perform this division exactly because $\Lambda$ is a power of two. Let $\Lambda = 2^m$ for some $m \in \mathbb{Z}$ and let $x$ have the IEEE representation
\[ x = (-1)^S (1.m_{1} \hdots m_{52})_2 * 2^{(e_1 \hdots e_{11})_2-1023}. \]
Then we know that
\[ x' = (-1)^S (1.m_{1} \hdots m_{52})_2 * 2^{(e_1 \hdots e_{11})_2-1023-m}. \]
We can rewrite $(e_1 \hdots e_{11})_2 - m$ as $(f_1 \hdots f_{11})_2$ and represent $x'$ directly as its IEEE implementation:
\[ x' = (-1)^S (1.m_{1} \hdots m_{52})_2 * 2^{(f_1 \hdots f_{11})_2-1023}. \]

\subsubsection{Round $x'$ to nearest integer}
Let $y = (f_1 \hdots f_{11})_2-1023$. We present slightly different rounding algorithms based on the value of $y$. Note that we abuse notation a bit below; the repeating element notation $\bar{0}$ means to repeat the element (in this case, 0) until the rest of the larger section has been filled. For example, if the mantissa is 52 bits, then $101\bar{0}$ represents $101$ followed by 49 trailing zeros. \newline

\textbf{Case 1: $y \geq 52$} \newline
If $y \geq 52$, then we know that only integers are able to be represented at this scale, so there is no need to round.\footnote{See \href{https://www.exploringbinary.com/the-spacing-of-binary-floating-point-numbers/}{here} for an explanation.} \newline

\textbf{Case 2: $y \in \{0, 1, \hdots, 51\}$} \newline
We can think of multiplying by $2^y$ as shifting the radix point to the right $y$ times. We can then write
\[ x' = (-1)^S (1m_1 \hdots m_y.m_{y+1} \hdots m_{52})_2. \]

We know $m_1 \hdots m_y$ represent powers of two $\in \mathbb{Z}$ and $m_{y+1} \hdots m_{52}$ are powers of two $\not \in \mathbb{Z}$. Specifically, $m_{y+1}$ corresponds to $\frac{1}{2}$. So, we know to round up if $m_{y+1} = 1$ and down if $m_{y+1} = 0$. \newline

Rounding up requires incrementing up by 1 the integral part of the mantissa ($m_1 \hdots m_y$), and changing the fractional part ($m_{y+1}, \hdots, m_{52}$) to zeros. Note that there is an edge case here where $m_i = 1$ for all $i$ in which the mantissa becomes $(\bar{0})_2$ and we instead increment the exponent. Rounding down requires maintaining the integral part of the mantissa and changing the fractional part to zeros. \newline

Let $(m'_1 \hdots m'_y)_2 = (m_1 \hdots m_y)_2 + 1$ and $(f'_1 \hdots f'_{11})_2 = (f_1 \hdots f_{11})_2 + 1$. Then we get:
\begin{equation}
    x'' =
        \begin{cases}
            (-1)^S (1.m'_1 \hdots m'_y \bar{0})_2 * 2^{(f_1 \hdots f_{11})_2-1023}, & \text{ if } m_{y+1} = 1 \text{ and } \exists i: m_i = 0 \\
            (-1)^S (1.\bar{0})_2 * 2^{(f'_1 \hdots f'_{11})_2-1023}, & \text{ if } m_{y+1} = 1 \text{ and } \forall i: m_i = 1 \\
            (-1)^S (1.m_1 \hdots m_y \bar{0})_2 * 2^{(f_1 \hdots f_{11})_2-1023}, & \text{ if } m_{y+1} = 0
        \end{cases}
\end{equation}

\textbf{Case 3: $y = -1$} \newline
We think of this case similarly to the beginning of Case 2 and shift the radix point to the left:
\[ x'' = (-1)^S (0.1m_1 m_2 \hdots)_2. \]
W know the bit directly to the right of the radix point is the implicit 1 in the IEEE representation, so we know we will round up. Rounding up always rounds to 1, so we know
\[ x'' = (-1)^S (1.\bar{0})_2 * 2^{(0\bar{1})_2 - 1023}. \]

\textbf{Case 4: $y < -1$} \newline
This is exactly the same as Case 3, except we know there are some number of leading zeros between the radix point and the implicit 1. Therefore, we always round down to 0 and get:
\[ x'' = (-1)^0 (1.\bar{0})_2 * 2^{(\bar{0})_2 - 1023}. \]
The notation directly above should not be taken literally, as 0 has a special IEEE representation (all 0s) that does not quite follow the standard formula. We present the standard formally for the sake of consistency and comparison with the earlier cases. \newline

\subsubsection{Multiply $x''$ by $\Lambda$}
Finally, we multiply $x''$ by $\Lambda$ to get our desired result. This is effectively the opposite of Step 1, in that we add $m$ to the exponent of $x''$. The only difference is that we now have to deal with the case in which $x'' = 0$, because $0*2^m \neq 0$ if you implement multiplication by $2^m$ through exponent addition.\footnote{This is due to the special representation of 0.}

\section{Redefinition of $\epsilon$}
Mironov states in the last line of the privacy proof that the snapping mechanism respects
\[ \left( \frac{1 + 12B\eta}{\lambda} + 2\eta \right)\text{-DP} \]
where $B$ is the clamping bound and $\eta$ is the machine-$\epsilon$.\footnote{This is a relatively minor point, but I have normally seen machine-$\epsilon$ defined as the smallest value $\epsilon$ such that $1 \oplus \epsilon \neq 1$. Mironov defines it as the largest $\epsilon$ such that $1 \oplus \epsilon = 1$.} We will take $\eta$ to be our floating-point precision, rather than a value that is machine-imposed, which allows us to use high-precision libraries to get smaller values of $\eta$.
Because we have rescaled our function to $\Delta f = 1$, we have $\delta = \frac{1}{\epsilon'}$ and this is equivalent to
\[ \big( \epsilon'(1 + 12B\eta) + 2\eta \big)\text{-DP}. \]
For ease of notation, we will call this $\epsilon$-DP and it can be thought of as the privacy level relative to the Laplace. That is, if you were to get $\epsilon'$-DP from the Laplace Mechanism, you would get $\epsilon$-DP from the Snapping Mechanism. Put another way, you get $\epsilon$-DP from the Snapping Mechanism when you use $\epsilon'$ to parameterize the Laplace noise that is embedded within the Snapping Mechanism. \newline

This is not really sufficient to be usable in a system that might require budgeting of a privacy budget, as you cannot (as written above) simply set a privacy allocation for the Snapping Mechanism, as it relies on $B$ and $\eta$. So rather than returning $\epsilon$ as a function of $\epsilon'$, we should do the reverse.
\begin{align}
             \epsilon &= \epsilon'(1 + 12B\eta) + 2\eta \nonumber \\
    \implies \epsilon' &= \frac{\epsilon - 2\eta}{1 + 12B \eta} \nonumber
\end{align}
This $\epsilon'$ is what will be used in the parameterization in the Laplace within the Snapping Mechanism. Thus, we need $\epsilon' > 0$, or $\epsilon > 2\eta$, where $\eta = 2^{-p}$, and $p$ is our floating point precision. This simplifies to $\epsilon > 2^{-p+1}$. Assuming we want minimum sufficient precision, we can find the smallest power of two $\geq \epsilon$, call it $2^{-m}$, and let $p = m+2$. For setting our mechanism-level precision, we use the larger of the $p$ we just found or the level necessary to perform exact rounding on the logarithm as described earlier (which we currently believe to be 118).

\section{Utility}
\subsection{Error}
As originally written, it is difficult to reason about error/utility of the Snapping Mechanism. The output of the Snapping Mechanism relies on the user-provided bound, $B$, which could potentially cause the output to be arbitrarily far from $f(D)$. The potential for bias of the Snapping Mechanism decreases as $B$ increases in absolute value. Note however that $\epsilon'$ decreases as $B$ increases, thus causing the amount of added Laplace noise to increase. Throughout this section, we will assume that $f(D) \geq 0$, though a very similar process can be taken to reason about $f(D) \leq 0$. Furthermore, we consider the case in which $\Delta f = 1$.
The accuracy/error calculations should be multiplied by $\Delta f$ for the case in which $\Delta f \neq 0$. \newline

One possibility is that, instead of the user choosing $B$, we set it for them within the mechanism. We can use the data bounds the user provides to calculate a bound on $f(D)$.\footnote{This should, at least theoretically, be possible for $f: \mathcal{X} \rightarrow \mathbb{R}$ if $f$ is continuous and $\mathcal{X}$ is compact (thanks to Ira/Wikipedia for pointing this out).} This will allow us to set a $B$ such that we are sure that $clamp_B \left( f(D) \right)$ is non-binding. This will make it a bit easier to think about the error of the mechanism, as every component of the mechanism is now something with a value or distribution we can reason about.
For now, we will ignore exactly how this is done and focus on general analysis assuming that such a $B$ can be chosen.

Consider the following quantity:
\[ N \sim \big \vert f(D) - clamp_B \big( \lfloor f(D) + Y' \rceil_{\Lambda'} \big) \big \vert \]
with $Y' \sim Laplace(\lambda')$ where $\lambda' = \frac{1}{e'} = \frac{1 + 12B \eta}{\epsilon - 2\eta}$. This is the amount of noise added to $f(D)$ by the snapping mechanism.\footnote{Note that we ignore the inner $clamp_B$ inside the Snapping Mechanism because we set $B \geq f(D)$.} We have then:
\begin{equation}
	N =
		\label{snapped_noise}
		\begin{cases}
			B + f(D), &\text{ if } clamp_B \left( \lfloor f(D) + Y' \rceil_{\Lambda'} \right) = -B  \\
			B - f(D), &\text{ if } clamp_B \left( \lfloor f(D) + Y' \rceil_{\Lambda'} \right) = B  \\
			\big\vert f(D) - \lfloor f(D) + Y' \rceil_{\Lambda'} \big\vert, &\text{ otherwise }
		\end{cases}
\end{equation}

We can examine these cases further. Let $F_{Y'}$ be the CDF of $Y' \sim Laplace(\lambda')$, which we write:
\begin{equation}
	F_{Y'}(x) =
		\begin{cases}
			\frac{1}{2} \exp \left( \frac{x}{\lambda'} \right), &\text{ if } x < 0 \\
			1 - \frac{1}{2} \exp \left( \frac{-x}{\lambda'} \right), &\text{ if } x \geq 0
		\end{cases}
\end{equation}

Then:
\begin{align}
	               \mathbb{P} \big( clamp_B\left( \lfloor f(D) + Y' \rceil_{\Lambda'} \right) = -B \big) \nonumber &= \mathbb{P} \big( \lfloor f(D) + Y' \rceil_{\Lambda'} < -B \big) \nonumber \\
	&\leq \mathbb{P} \big( f(D) + Y' < -B + \frac{\Lambda'}{2} \big) \nonumber \\
	&= \mathbb{P} \big( Y' < -B - f(D) + \frac{\Lambda'}{2} \big) \nonumber \\
	&= F_{Y'} \big( -B - f(D) + \frac{\Lambda'}{2} \big) \nonumber
\end{align}

\begin{align}
	               \mathbb{P} \big( clamp_B\left( \lfloor f(D) + Y' \rceil_{\Lambda'} \right) = B \big) \nonumber &= \mathbb{P} \big( \lfloor f(D) + Y' \rceil_{\Lambda'} \geq B \big) \nonumber \\
	&\leq \mathbb{P} \big( f(D) + Y' \geq B - \frac{\Lambda'}{2} \big) \nonumber \\
	&= \mathbb{P} \big( Y' \geq B - f(D) - \frac{\Lambda'}{2} \big) \nonumber \\
	&= 1 - \mathbb{P} \big( Y' < B - f(D) - \frac{\Lambda'}{2} \big) \nonumber \\
	&= 1 - F_{Y'} \big( B - f(D) - \frac{\Lambda'}{2} \big) \nonumber
\end{align}

Recall from the triangle inequality that $\vert x-z \vert \leq \vert x-y \vert + \vert y-z \vert$. Then we have
\begin{align}
\big\vert f(D) - \lfloor f(D) + Y' \rceil_{\Lambda'} \big\vert \nonumber &\leq \big\vert f(D) - (f(D) + Y') \big\vert + \big\vert f(D) + Y' - \lfloor f(D) + Y' \rceil_{\Lambda'} \big\vert \nonumber \\
                                                                        &\leq \vert -Y' \vert + \frac{\Lambda'}{2} \nonumber \\
	                                                                    &= \vert Y' \vert + \frac{\Lambda'}{2} \nonumber
\end{align}
It is important to note that this $Y'$ is associated with the Laplace noise inside the snapping mechanism which uses the redefined $\epsilon'$, rather than the user's desired $\epsilon$. So, we need to do a bit more work in order to compare the error of the Snapping Mechanism to that we would get if we instead used a Laplace Mechanism with the same nominal privay guarantee. \newline

Let $Y \sim Laplace(\lambda)$, where $\lambda = \frac{1}{\epsilon}$, be the distribution of noise generated by the Laplace Mechanism.
We showed in \autoref{subsec:snapping} that we can represent the distribution of Laplace noise as $S \otimes \lambda \otimes LN(U^*)$. So, we have
\[ Y \sim S \otimes \frac{1}{\epsilon} \otimes LN(U^*) \]
\[ Y' \sim S \otimes \frac{1 + 12B\eta}{\epsilon - 2\eta} \otimes LN(U^*) \]
and thus,
\[ Y' = \frac{\epsilon(1 + 12B\eta)}{\epsilon - 2\eta}Y \]

So we can rewrite $\eqref{snapped_noise}$ as
\begin{equation}
	\label{snapped_noise_rewrite}
	N
		\begin{cases}
			= B + f(D), &\text{ with probability } \leq F_{Y'} \big( -B - f(D) + \frac{\Lambda'}{2} \big)  \\
			= B - f(D), &\text{ with probability } \leq 1 - F_{Y'} \big( B - f(D) - \frac{\Lambda'}{2} \big)  \\
			\leq \vert Y' \vert + \frac{\Lambda'}{2}, &\text{ otherwise }
		\end{cases}
\end{equation}
Note that $N$ is always $\leq B + f(D)$.

\subsection{Accuracy}
We would like to convert the error into an accuracy estimate. Keeping in line with existing standards in PSI-Library, we define the accuracy $a$ for a given $\alpha$ as the $a$ such that $\alpha = \mathbb{P}(N > a)$, where $N$ is (as above) the error (relative to $f(D)$) introduced by the Snapping Mechanism. It is difficult to get an exact accuracy guarantee because of our inability to model the effects of $\lfloor \cdot \rceil_\Lambda'$, so we will instead refer to $a$ as the smallest $x$ such that $\mathbb{P}(N > x) \leq \alpha$. \newline

Recall that $N \leq B + f(D)$. If we can get an upper bound on $P_{L} = \mathbb{P}(N = B + f(D))$, then we can start concerning ourselves only with the second two lines of $\eqref{snapped_noise_rewrite}$, which we will call $N_{sub}$. \newline

Let's attempt to get bounds on $P_{L} = \mathbb{P}(N = B + f(D))$ and $P_{U} = \mathbb{P}(N = B - f(D))$ in terms of quantities we know. Remember that $\frac{\lambda'}{2} \leq \frac{\Lambda'}{2} < \lambda'$.
\begin{align}
	P_{L} &= \mathbb{P}(N = B + f(D)) \nonumber \\
		  &= F_{Y'}(-B - f(D) + \frac{\Lambda'}{2}) \nonumber \\
		  &< F_{Y'}(-B - f(D) + \lambda') \nonumber \\
		  &= P_{L}^{+} \nonumber
\end{align}
\begin{align}
	P_{U} &= \mathbb{P}(N = B - f(D)) \nonumber \\
		  &= 1 - F_{Y'}(B - f(D) - \frac{\Lambda'}{2}) \nonumber \\
		  &\geq 1 - F_{Y'}(B - f(D) - \lambda') \nonumber \\
		  &= P_{U}^{-} \nonumber
\end{align}
Because we know that $\mathbbm{P}(N=B+f(D)) \leq P_L < P_{L}^{+}$, we can reframe our original goal. We wanted to find the smallest $x$ such that $\alpha \geq \mathbb{P}(N > x)$, but this is equivalent to finding the smallest $x$ such that
\[ \alpha - P_{L}^{+} \geq \mathbb{P}(N_{sub} > x) \]
which we further reinterpret as
\[ \alpha - P_{L}^{+} \geq 1 - \mathbb{P}(N_{sub} \leq x) = 1 - F_{N_{sub}}(x). \]
Consider $N_{sub}$; we know that
\[ Y' \sim Laplace (\lambda') \]
with $\lambda' = \frac{1}{\epsilon'} = \frac{1 + 12B \eta}{\epsilon - 2 \eta}$, which implies that
\[ \vert Y' \vert \sim Exponential(\epsilon'). \]
We now construct upper and lower bounds on the CDF of $Z = \vert Y' \vert + \frac{\Lambda'}{2}$, which we will call $F_{Z}$:
\begin{align}
	F_{Z}(z) &= \mathbb{P}(Z \leq z) \nonumber \\
			 &= \mathbb{P}\left( \vert Y' \vert + \frac{\Lambda'}{2} \leq z \right) \nonumber \\
			 &= \mathbb{P} \left( \vert Y' \vert \leq z - \frac{\Lambda'}{2} \right) \nonumber \\
			 &\leq \mathbb{P} \left( \vert Y' \vert \leq z - \frac{\lambda'}{2} \right) \nonumber \\
			 &= 1 - \exp\left( -\epsilon'(z - \frac{\lambda'}{2}) \right) \nonumber \\
			 &= 1 - \exp\left( -\epsilon'z + \frac{1}{2} \right) \nonumber \\
			 &= F_{Z}^{+}(z) \nonumber
\end{align}
\begin{align}
	F_{Z}(z) &= \mathbb{P}(Z \leq z) \nonumber \\
			 &= \mathbb{P}\left( \vert Y' \vert + \frac{\Lambda'}{2} \leq z \right) \nonumber \\
			 &= \mathbb{P} \left( \vert Y' \vert \leq z - \frac{\Lambda'}{2} \right) \nonumber \\
			 &> \mathbb{P} \left( \vert Y' \vert \leq z - \lambda' \right) \nonumber \\
			 &= 1 - \exp\left( -\epsilon'(z - \lambda') \right) \nonumber \\
			 &= 1 - \exp\left( -\epsilon'z + 1 \right) \nonumber \\
			 &= F_{Z}^{-}(z) \nonumber
\end{align}

Let $f_Z$ be the PDF of $Z$, $m = \min\left(B-f(D),x\right)$, and $n = \min\left(B+f(D),x\right)$.  Then we have:
\begin{align}
	F_{N_{sub}}(x) &= \int_{0}^{m} f_{Z}(z)dz + \left( P_{U} + \int_{B - f(D)}^{n} f_{Z}(z)dz \right) \cdot \mathbbm{1}\left(x \geq B - f(D)\right) \nonumber \\
				   &= F_{Z}(m) + \left( P_{U}  + F_{Z}(n) - F_{Z}(B - f(D)) \right) \cdot \mathbbm{1}\left( x \geq B - f(D) \right)   \nonumber \\
				   &\geq F_{Z}^{-}(m) + \left( P_{U}^{-} + F_{Z}^{-}(n) - F_{Z}^{+}(B - f(D) \right) \cdot \mathbbm{1}\left(x \geq B - f(D)\right) \nonumber \\
				   &= F_{N_{sub}}^{-}(x) \nonumber
\end{align}
Now that we have $F_{N_{sub}}^{-}(x)$ as a lower bound on $F_{N_{sub}}(x)$, we know that
$1 - F_{N_{sub}}^{-}(x)$ is an upper bound on $1 - F_{N_{sub}}(x)$.
So, our objective is now to find the minimum $x$ such that $1 - F_{N_{sub}}^{-}(x) = \alpha - P_{L}^{+}$.
We rewrite this condition as $F_{N_{sub}}^{-}(x) = 1 + P_{L}^{+} - \alpha$. \newline

Observe that if for a given $x'$ we have
$F_{Z}^{-}(x') \geq 1 + P_{L}^{+} - \alpha$, we know that
\[ \exists x \leq x': x = 1 + P_{L}^{+} - \alpha \]
We can find this $x$ by performing algebra on $F_{Z}^{-}(x)$, which yields the following algorithm:

\begin{algorithm}
	\label{GetAccuracy}
	\begin{algorithmic}
		\Function{GetAccuracy}{$f(D), B, P_{L}^{+}, P_{U}^{-}, \epsilon', \alpha$}
			\If{$P_{L}^{+} \geq \alpha$}
				\State\Return{B + f(D)}
			\ElsIf{$F^{-}_{Z}(B - f(D)) \geq 1 + P_{L}^{+} - \alpha$}
				\State\Return{$\frac{1 - \ln(\alpha - P_{L}^{+})}{\epsilon'}$}
			\ElsIf{$F^{-}_{Z}(B - f(D)) + P_{U}^{-} \geq 1 + P_{L}^{+} - \alpha$}
				\State\Return{B - f(D)}
			\Else{}
				\State\Return{$\frac{1 - \ln(\alpha - P_{L}^{+} + P_{U}^{-})}{\epsilon'}$}
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}
Calculations/explanations of the return statements above can be found in Appendix $\autoref{appendix:accuracy}$. \newline

There are some complications with \emph{GetAccuracy}. \newline

First, it relies on $f(D)$ and thus is privacy-leaking. I have not yet figured out the privacy loss of releasing the accuracy,
but we could work on this in the future. James suggested that we could potentially give simulated accuracy estimates
for estimates of $f(D)$ provided by the user, thus removing the dependance on the real $f(D)$.
I think that if we did this, we could not give a post-hoc accuracy guarantee using \emph{GetAccuracy}
(it would be too easy for a user to ask for an exhaustive list of accuracies for possible $f(D)$ and then back out the true
$f(D)$ from the provided post-hoc accuracy guarantee). \newline

Second (though related), the accuracy guarantee using the actual $f(D)$ cannot be done until the mechanism has been run,
so the user cannot get a certain accuracy guarantee before running the algorithm in order to decide whether or
not they want to spend some of their privacy budget on the statistic. \newline

We instead use a more conservative accuracy metric that will be independent of $D$.\footnote{Thanks to Victor Balcer for motivating
this idea.} Note that, provided that $f(D) \in [-B, B]$ (as is guaranteed by our method for choosing $B$),
the outer $clamp_B$ (after noise is added) can only help our accuracy. Thus, we can model the noise as always being upper bounded by
$Z = \vert Y' \vert + \frac{\Lambda'}{2}$ and ignore the cases in which the outer clamping binds bound. \newline

Let's first consider the question of, for a given accuracy $a$, finding confidence $\alpha$ such that
$\mathbbm{P}(Z \geq a) \leq \alpha$. We would like for $\alpha$ to be as small as possible, though any sufficiently large
$\alpha$ would satisfy our needs.

\begin{align*}
	\mathbbm{P}(Z \geq a) &= 1 - F_{Z}(a) \\
						  &\leq 1 - F_{Z}^{-}(a) \\
						  &= 1 - (1 - \exp(-\epsilon' a + 1)) \\
						  &= \exp(-\epsilon' a + 1)
\end{align*}
and so we have
\[ \alpha = \exp(-\epsilon' a + 1). \]
We can rearrange and solve for $a$ to put this in the terms we were using earlier (finding a suitable accuracy $a$ for
a given $\alpha$). That calculation yields
\[ a = \frac{1 - \ln(\alpha)}{\epsilon'} = \frac{1 + \ln \left( \frac{1}{\alpha} \right)}{\epsilon'}. \]

The algorithm for getting accuracy is then as follows. Notice that we can clamp our accuracy guarantee to $2B$ if it
exceeds this, as the outer clamp ensures that the mechanism output is $\in [-B, B]$.
\begin{algorithm}
	\label{GetAccuracy2}
	\begin{algorithmic}
		\Function{GetAccuracy2}{$B, \epsilon', \alpha$}
			\State $a = \frac{1 + \ln \left( \frac{1}{\alpha} \right)}{\epsilon'}$
			\If{$a \geq 2B$}
					\State\Return{2B}
			\Else{}
				\State\Return{a}
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The accuracy for the pure Laplace is given as $\frac{\ln \left( \frac{1}{\alpha} \right)}{\epsilon}$. Recalling that
$\epsilon' = \frac{\epsilon - 2\eta}{1 + 12B\eta}$ we can represent the difference between the accuracy of the
Snapping and Laplace as follows:
\begin{align*}
	a_{Snapping} &= \frac{1 + \ln \left( \frac{1}{\alpha} \right)}{\epsilon'} \\
			     &= \frac{1 + \ln \left( \frac{1}{\alpha} \right)}{\left( \frac{\epsilon - 2\eta}{1 + 12B\eta} \right)} \\
			     &= \frac{(1 + 12B \eta) \left( 1 + \ln \left( \frac{1}{\alpha} \right) \right)}{\epsilon - 2\eta} \\
				 &= \frac{1 + 12B \eta}{\epsilon - 2\eta} \cdot \frac{1 + \ln \left( \frac{1}{\alpha} \right)}{\epsilon - 2\eta} \\
				 &= \frac{1 + 12B \eta}{\epsilon - 2\eta} \cdot \frac{1 + \ln \left( \frac{1}{\alpha} \right)}{\epsilon} \cdot \frac{\epsilon}{\epsilon - 2\eta} \\
				 &= \frac{\epsilon(1 + 12B \eta)}{\left( \epsilon - 2\eta \right)^2} \cdot \left( \frac{1}{\epsilon} + \frac{\ln \left( \frac{1}{\alpha} \right)}{\epsilon} \right) \\
				 &= \frac{1 + 12B \eta}{\left( \epsilon - 2\eta \right)^2}
				 + \frac{\epsilon(1 + 12B \eta)}{\left( \epsilon - 2\eta \right)^2} \cdot a_{Laplace}
\end{align*}

\subsection{Bias}
Because of the clamping to $[-B,B]$, the snapping mechanism will almost always bias estimates towards $0$.
I am not yet sure if it would be possible to give information about bias of the released statistic without leaking information
about the data (I lean towards thinking that it is not), but I believe we could provide the bias for a statistic for
a user's guesses about what $f(D)$ might be. \newline

Let $f'(D)$ be the user's estimate of $f(D)$ and $\tilde{f}'(D)$ be the output of the snapping mechanism as applied to
$f'(D)$. Without loss of generality, we will assume that $f'(D) \geq 0$. If it were not, we could
multiply $f'(D)$ by $-1$ and use this algorithm to get the correct result.\footnote{(This works because our bounds, $-B, B$, are symmetric about $0$.)}
We think about the distribution of noise not as the absolute value of noise (which we used earlier), but as
being some distribution with support $[-B - f'(D), B - f'(D)]$. \newline

We write the bias of the snapping mechanism as
\[ Bias = \E(\tilde{f}'(D) - f'(D)) = \E\left( clamp_B\left( \lfloor f'(D) + Y \rceil_{\Lambda'} \right) - f'(D) \right) \]
where $Y \sim Laplace(\lambda')$ and the expectation is over the randomness of the snapping mechanism.
Note that bias is a property of the snapping, not of any individual output of the mechanism.
Thus, any individual output from the snapping mechanism could be as far as $2B$ from the actual raw statistic
we wish to estimate. \newline

To avoid trying to model the effects of $\lfloor \cdot \rceil_{\Lambda'}$ directly, we will move to considering
a new quantity we will call $Bias^{+}$, which is an upper bound on the bias:
\[ Bias^{+} = \E\left( clamp_B\left( f'(D) + Y^{*} \right) - f'(D) \right) \]
where $Y^{*} \sim Laplace(-\frac{\Lambda}{2}, \lambda')$.\footnote{I believe this works,
but need to think of how to prove it.} Now, define the following:
\[ p_L = F_{Y^*}(-B - f'(D)) \]
\[ p_U = 1 - F_{Y^*}(B - f'(D)) \]
such that $F_{Y^*}$ is the CDF of $Y^*$ and $p_L, p_U$ are the probabilities that the lower/upper bounds are binding (respectively).
Then we can write
\[ Bias^+ = p_L \cdot (-B - f'(D)) + p_U \cdot (B - f'(D)) + (1-p_l-p_U) \cdot \int_{-B-f'(D)}^{B-f(D)}y^* f(y^*) dy^* \]
where $f$ is the PDF of $Y^*$. \newline

There may be other notions of bias we could provide to a user. For example, the maximum possible bias
(i.e. when $f(D) = \pm B$) (already included in the code), or the expected bias over a set/distribution of $f'(D)$ (not
yet implemented).

% Appendices
\begin{appendices}
	\section{Accuracy Calculations}
	\label{appendix:accuracy}
	We iterate over the possible cases for where our optimal $a$ could lie.
	We consider the sections of the PDF of $N$ representing where the bounds bind (Cases 1 and 3) as special cases, and use our bounds on
	$F_{Z}$ for the sections between the bounds.

	\textbf{Case 1:} $P_{L}^{+} \geq \alpha$ \newline
	$P_{L}^{+} \geq \alpha$ means that the largest bound ($B + f(D)$) on the noise binds with probability $\geq \alpha$.
	So, we can make no tighter accuracy guarantee at the $\alpha$ level than bounding by the greatest possible noise $B + f(D)$. \newline

	\textbf{Case 2:} Case 1 does not hold and $F^{-}_{Z}(B - f(D)) \geq 1 + P_{L}^{+} - \alpha$ \newline
	We know $a = x \leq B - f(D): F_{Z}^{-}(x) = 1 + P_{L}^{+} - \alpha$.
	\begin{align}
	              	 F_{Z}^{-}(a) &= 1 + P_{L}^{+} - \alpha \nonumber \\
		1 - \exp(-\epsilon'a + 1) &= 1 + P_{L}^{+} - \alpha \nonumber \\
		           \epsilon'a + 1 &= \ln(\alpha - P_{L}^{+}) \nonumber \\
		                        a &= \frac{1 - \ln(\alpha - P_{L}^{+})}{\epsilon'} \nonumber
	\end{align}

	\textbf{Case 3:} Case 1,2 do not hold and $F^{-}_{Z}(B - f(D)) + P_{U}^{-} \geq 1 + P_{L}^{+} - \alpha$ \newline
	This is conceptually similar to Case 1, in the sense that the probability of a bound binding (in this case, the bound if $B - f(D)$) pushes us past our
	$\alpha$ level. Similar to before, we can make an accuracy guarantee that corresponds to the binding bound, $B - f(D)$. \newline

	\textbf{Case 4:} Case 1,2,3 do not hold \newline
	We know $a =  x \in (B - f(D), B + f(D))$ such that
	\[ F_{Z}^{-}(x) - F_{Z}^{-}(B - f(D)) = 1 + P_{L}^{+} - \alpha - F_{Z}^{-}(B - f(D)) - P_{U}^{-} \]
	\begin{align}
		F_{Z}^{-}(a) - F_{Z}^{-}(B - f(D)) &= 1 + P_{L}^{+} - \alpha - F_{Z}^{-}(B - f(D)) - P_{U}^{-} \nonumber \\
							  F_{Z}^{-}(a) &= 1 + P_{L}^{+} - \alpha - P_{U}^{-} \nonumber \\
				1 - \exp(-\epsilon' a + 1) &= 1 + P_{L}^{+} - \alpha - P_{U}^{-} \nonumber \\
						  -\epsilon' a + 1 &= \ln(\alpha - P_{L}^{+} + P_{U}^{-}) \nonumber \\
						                 a &= \frac{1 - \ln(\alpha - P_{L}^{+} + P_{U}^{-})}{\epsilon'} \nonumber
	\end{align}
\end{appendices}

\end{document}